%%% Copyright (c) Meta Platforms, Inc. and……         |
%%%                                        |         |
%%% This source code is licensed under the……         |
%%% the LICENSE file in the root directory……         |
                                           |         |
-module(fault_tolerance).                  |         |
                                           |         |
-compile([export_all, nowarn_export_all]). |         |
                                           |         |
% eqwalizer:ignore                         |         |
-behaviour(gen_server).                    |         |
                                           |         |
-spec b_to_n(boolean()) ->                 |         |
  number().                                |         |
b_to_n(false) ->                           | OK      |
  0;                                       |         |
b_to_n(true) ->                            |         |
  1.                                       |         |
                                           |         |
-spec b_to_n1(boolean()) ->                |         |
  number().                                |         |
b_to_n1(true) ->                           | ERROR   |
  true;                                    |         | 'true'.
                                           |         | Expression has type:   'true'
                                           |         | Context expected type: number()
b_to_n1(false) ->                          |         |
  false.                                   |         | 'false'.
                                           |         | Expression has type:   'false'
                                           |         | Context expected type: number()
                                           |         |
-spec b_to_n2(boolean()) ->                |         |
  number().                                |         |
b_to_n2(true) ->                           | ERROR   |
  1;                                       |         |
b_to_n2(A) ->                              |         |
  A.                                       |         | A.
                                           |         | Expression has type:   'false' | none()
                                           |         | Context expected type: number()
                                           |         | 
                                           |         |   'false' | none() is not compatible with number()
                                           |         |   because
                                           |         |   'false' is not compatible with number()
                                           |         |
-spec b_to_n3(boolean()) ->                |         |
  number().                                |         |
b_to_n3(true) ->                           | ERROR   |
  true;                                    |         | 'true'.
                                           |         | Expression has type:   'true'
                                           |         | Context expected type: number()
b_to_n3(A) ->                              |         |
  A.                                       |         | A.
                                           |         | Expression has type:   'false' | none()
                                           |         | Context expected type: number()
                                           |         | 
                                           |         |   'false' | none() is not compatible with number()
                                           |         |   because
                                           |         |   'false' is not compatible with number()
                                           |         |
-spec opacity_tolerance                    |         |
    (atom(), misc:o()) -> atom().          |         |
opacity_tolerance(a, _) ->                 | ERROR   |
  1;                                       |         | 1.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
opacity_tolerance(b, _) ->                 |         |
  2;                                       |         | 2.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
opacity_tolerance(_, {_}) ->               |         |
  3;                                       |         | 3.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
opacity_tolerance(c, _) ->                 |         |
  4.                                       |         | 4.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-spec too_many_errors                      |         |
    (atom()) -> atom().                    |         |
too_many_errors(a) ->                      | ERROR   |
  1;                                       |         | 1.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
too_many_errors(b) ->                      |         |
  2;                                       |         | 2.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
too_many_errors(c) ->                      |         |
  3;                                       |         | 3.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
too_many_errors(d) ->                      |         |
  4;                                       |         | 4.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
too_many_errors(e) ->                      |         |
  5;                                       |         | 5.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
too_many_errors(f) ->                      |         |
  6;                                       |         |
too_many_errors(g) ->                      |         |
  7;                                       |         |
too_many_errors(h) ->                      |         |
  8;                                       |         |
too_many_errors(i) ->                      |         |
  9;                                       |         |
too_many_errors(j) ->                      |         |
  10.                                      |         |
                                           |         |
-spec visible_cast                         |         |
    (number()) -> number().                |         |
visible_cast(N) ->                         | ERROR   |
  erlang:atom_to_binary(                   |         | erlang:atom_to_binary(eqwalizer:dynamic_cast(b_to_n(eqwalizer:dynamic_cast(N)))).
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: number()
    b_to_n(                                |         | b_to_n(eqwalizer:dynamic_cast(N)).
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
      N                                    |         | N.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: boolean()
    )                                      |         |
  ).                                       |         |
                                           |         |
-spec expected_fun(any()) ->               |         |
  number().                                |         |
expected_fun(F) ->                         | ERROR   |
  X = F(),                                 |         | F.
                                           |         | Expected fun type with arity 0
                                           |         | Got: term()
  Y = F(),                                 |         | F.
                                           |         | Expected fun type with arity 0
                                           |         | Got: term()
  {X, Y}.                                  |         | {X, Y}.
                                           |         | Expression has type:   {dynamic(), dynamic()}
                                           |         | Context expected type: number()
                                           |         |
-spec lambda_arity([number()], atom()) ->  |         |
  number().                                |         |
lambda_arity(Ns, A) ->                     | ERROR   |
  X = lists:map(fun(_X, _Y) -> 1 end, Ns), |         | fun.
                                           |         | fun with arity 2 used as fun with 1 arguments
  Y =                                      |         |
    X +                                    |         | X.
                                           |         | Expression has type:   [dynamic()]
                                           |         | Context expected type: number()
      A,                                   |         | A.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
  Y.                                       |         |
                                           |         |
%% SUBTLE/INTERESTING CASES %%             |         |
%% More errors are reported comparing      |         |
%% to "sentinel" approach.                 |         |
                                           |         |
-spec lists_append                         |         |
    (map(), map()) -> map().               |         |
lists_append(M1, M2) ->                    | ERROR   |
  Res = lists:append(                      |         |
    M1,                                    |         | M1.
                                           |         | Expression has type:   #D{dynamic() => dynamic()}
                                           |         | Context expected type: [T]
    M2                                     |         | M2.
                                           |         | Expression has type:   #D{dynamic() => dynamic()}
                                           |         | Context expected type: [dynamic()]
  ),                                       |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   [dynamic()]
                                           |         | Context expected type: #D{dynamic() => dynamic()}
                                           |         |
-spec maps_update1                         |         |
    (term(), atom(), atom()) -> atom().    |         |
maps_update1(M, K, V) ->                   | ERROR   |
  M1 = M#{                                 |         | M.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
    K :=                                   |         |
      V +                                  |         | V.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
        V},                                |         | V.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
  M1.                                      |         |
                                           |         |
% Similar                                  |         |
-spec maps_update2                         |         |
    (term(), atom(), atom()) -> atom().    |         |
maps_update2(M, K, V) ->                   | ERROR   |
  M1 = M#{                                 |         | M.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: #D{term() => term()}
    K =>                                   |         |
    V +                                    |         | V.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
      V},                                  |         | V.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
  M1.                                      |         |
                                           |         |
% Similar                                  |         |
-spec lists_flatten                        |         |
    (term(), any()) -> atom().             |         |
lists_flatten(L1, L2) ->                   | ERROR   |
  Res =                                    |         |
    lists:flatten(                         |         |
      L1,                                  |         | L1.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: [term()]
      L2                                   |         | L2.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: [term()]
    ),                                     |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   [dynamic()]
                                           |         | Context expected type: atom()
                                           |         |
%% Code coverage                           |         |
                                           |         |
-spec block                                |         |
    (term(), any()) -> atom().             |         |
block(X, Y) ->                             | ERROR   |
  begin                                    |         |
    Z =                                    |         |
      X +                                  |         | X.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: number()
        Y,                                 |         | Y.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: number()
    Z                                      |         | Z.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
  end.                                     |         |
                                           |         |
-spec cons                                 |         |
    (term(), any()) -> [atom()].           |         |
cons(H, T) ->                              | ERROR   |
  Res = lists:append(                      |         |
    [H |                                   |         | T.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: [term()]
      T],                                  |         |
    [T |                                   |         | H.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: [term()]
      H]                                   |         |
  ),                                       |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: [atom()]
                                           |         | 
                                           |         |   [term()] is not compatible with [atom()]
                                           |         |   because
                                           |         |   term() is not compatible with atom()
                                           |         |
-spec 'case'                               |         |
    (boolean(), atom()) -> number().       |         |
'case'(F, A) ->                            | ERROR   |
  case F() of                              |         | F.
                                           |         | Expected fun type with arity 0
                                           |         | Got: boolean()
    true -> A + 1;                         |         | A.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
    false -> A - 1                         |         | A.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
  end.                                     |         |
                                           |         |
-spec 'if'                                 |         |
    (boolean(), atom()) -> number().       |         |
'if'(F, A) ->                              | ERROR   |
  if                                       |         |
    F -> A + 1;                            |         | A.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
    true -> A - 1                          |         | A.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
  end.                                     |         |
                                           |         |
-spec dyn_call                             |         |
    (module(), atom()) -> ok.              |         |
dyn_call(M, F) ->                          | ERROR   |
  M:F(                                     |         |
    F + 1,                                 |         | F.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
    -M                                     |         | M.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
  ).                                       |         |
                                           |         |
-spec comprehensions1() -> ok.             |         |
comprehensions1() ->                       | ERROR   |
  [X ||                                    |         | [ || ].
                                           |         | Expression has type:   [dynamic()]
                                           |         | Context expected type: 'ok'
    X <- #{                                |         | #{..}.
                                           |         | Expression has type:   #S{a := 'b', c := number()}
                                           |         | Context expected type: [term()]
      a => b,                              |         |
      c => d + 1                           |         | 'd'.
                                           |         | Expression has type:   'd'
                                           |         | Context expected type: number()
    },                                     |         |
    atom_to_binary(                        |         |
      {X}                                  |         | {X}.
                                           |         | Expression has type:   {dynamic()}
                                           |         | Context expected type: atom()
    )].                                    |         |
                                           |         |
-spec comprehensions2([term()]) -> ok.     |         |
comprehensions2(L) ->                      | ERROR   |
  Res = [                                  |         |
    atom_to_binary(Y) ||                   |         | Y.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
    <<Y>> <= L                             |         | L.
                                           |         | Expression has type:   [term()]
                                           |         | Context expected type: binary()
  ],                                       |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   [binary()]
                                           |         | Context expected type: 'ok'
                                           |         |
-spec comprehensions3(binary()) -> ok.     |         |
comprehensions3(B) ->                      | ERROR   |
  Res =                                    |         |
    <<Y || Y <-                            |         |
      B                                    |         | B.
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: [term()]
    >>,                                    |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: 'ok'
                                           |         |
-spec maps(map()) ->                       |         |
  ok.                                      |         |
maps(M) ->                                 | ERROR   |
  M1 = M                                   |         |
    #{id := a + 1},                        |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
  M2 = M                                   |         |
    #{id := b + 2},                        |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: number()
  M1 + M2.                                 |         | M1.
                                           |         | Expression has type:   #D{dynamic() | 'id' => dynamic() | number()}
                                           |         | Context expected type: number()
                                           |         | ---
                                           |         | M2.
                                           |         | Expression has type:   #D{dynamic() | 'id' => dynamic() | number()}
                                           |         | Context expected type: number()
                                           |         | ---
                                           |         | _ + _.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: 'ok'
                                           |         |
-spec binary1(atom(), atom()) -> atom().   |         |
binary1(A, S) ->                           | ERROR   |
  B = <<                                   |         |
    A:                                     |         | A.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
    S                                      |         | S.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
  >>,                                      |         |
  B + 1.                                   |         | B.
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: number()
                                           |         | ---
                                           |         | _ + _.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: atom()
                                           |         |
-spec 'catch'(atom()) -> atom().           |         |
'catch'(F) ->                              | ERROR   |
  Res =                                    |         |
    catch F(),                             |         | F.
                                           |         | Expected fun type with arity 0
                                           |         | Got: atom()
  Res.                                     |         |
                                           |         |
-spec try1(atom()) -> atom().              |         |
try1(A) ->                                 | ERROR   |
  Res = try                                |         |
    A()                                    |         | A.
                                           |         | Expected fun type with arity 0
                                           |         | Got: atom()
  catch _ ->                               |         |
    []                                     |         |
  after                                    |         |
    1 + a                                  |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
  end,                                     |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   dynamic() | []
                                           |         | Context expected type: atom()
                                           |         | 
                                           |         |   dynamic() | [] is not compatible with atom()
                                           |         |   because
                                           |         |   [] is not compatible with atom()
                                           |         |
-spec try2(atom()) -> atom().              |         |
try2(A) ->                                 | ERROR   |
  Res = try                                |         |
          A()                              |         | A.
                                           |         | Expected fun type with arity 0
                                           |         | Got: atom()
        of                                 |         |
          {_} ->                           |         |
            A + 1                          |         | A.
                                           |         | Expression has type:   atom()
                                           |         | Context expected type: number()
        catch _ ->                         |         |
          []                               |         |
        after                              |         |
          1 + a                            |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
        end,                               |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   number() | []
                                           |         | Context expected type: atom()
                                           |         |
-record(rec, {                             |         |
  id :: integer(),                         |         |
  pid :: pid()                             |         |
}).                                        |         |
                                           |         |
-spec rec1(pid(), integer()) -> atom().    |         |
rec1(Pid, Id) ->                           | ERROR   |
  Res = #rec{                              |         |
    id = Pid,                              |         | Pid.
                                           |         | Expression has type:   pid()
                                           |         | Context expected type: number()
    pid = Id                               |         | Id.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: pid()
  },                                       |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   #rec{}
                                           |         | Context expected type: atom()
                                           |         |
-spec rec2(#rec{}, integer()) -> pid().    |         |
rec2(Rec, Id) ->                           | ERROR   |
  Res = Rec#rec{                           |         |
    pid = Id                               |         | Id.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: pid()
  },                                       |         |
  Res#rec.id.                              |         | ...#rec.id.
                                           |         | Expression has type:   number()
                                           |         | Context expected type: pid()
                                           |         |
-spec rec3() -> atom().                    |         |
rec3() ->                                  | ERROR   |
  Res = #rec{                              |         |
    _ = <<>>                               |         | <<..>>.
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: number()
  },                                       |         |
  Res.                                     |         | Res.
                                           |         | Expression has type:   #rec{}
                                           |         | Context expected type: atom()
                                           |         |
-spec receive1()                           |         |
      -> number().                         |         |
receive1() ->                              | ERROR   |
  receive                                  |         |
    {N} ->                                 |         |
      atom_to_binary(                      |         | erlang:atom_to_binary(eqwalizer:dynamic_cast(_ ++ _)).
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: number()
        [N]                                |         | _ ++ _.
                                           |         | Expression has type:   [dynamic()]
                                           |         | Context expected type: atom()
          ++ a                             |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: [term()]
      );                                   |         |
    N ->                                   |         |
      atom_to_binary(                      |         |
        <<N>>                              |         | <<..>>.
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: [term()]
          ++ b                             |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: [term()]
      )                                    |         |
  end.                                     |         |
                                           |         |
-spec receive2()                           |         |
      -> number().                         |         |
receive2() ->                              | ERROR   |
  receive                                  |         |
    {N} ->                                 |         |
      atom_to_binary(                      |         | erlang:atom_to_binary(eqwalizer:dynamic_cast([N])).
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: number()
        [N]                                |         | [N].
                                           |         | Expression has type:   [dynamic()]
                                           |         | Context expected type: atom()
      );                                   |         |
    N ->                                   |         |
      atom_to_binary(                      |         | erlang:atom_to_binary(eqwalizer:dynamic_cast(<<..>>)).
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: number()
        <<N>>                              |         | <<..>>.
                                           |         | Expression has type:   binary()
                                           |         | Context expected type: atom()
      )                                    |         |
  after 10 ->                              |         |
    []                                     |         | [].
                                           |         | Expression has type:   []
                                           |         | Context expected type: number()
  end.                                     |         |
                                           |         |
-spec same_line() -> number().             |         |
same_line() ->                             | ERROR   |
  a + b.                                   |         | 'a'.
                                           |         | Expression has type:   'a'
                                           |         | Context expected type: number()
                                           |         | ---
                                           |         | 'b'.
                                           |         | Expression has type:   'b'
                                           |         | Context expected type: number()
                                           |         |
% eqwalizer:ignore                         |         |
-type loop() :: loop().                    |         |
                                           |         |
-spec use_invalid(loop()) -> none().       | INVALID | use_invalid/1 references type with invalid definition: loop/0

use_invalid(Dyn) ->                        |         |
  Dyn.                                     |         |
                                           |         |
-spec fixmes(atom()) -> ok.                |         |
fixmes(Atom) ->                            | OK      |
  % eqwalizer:fixme                        |         |
  _ = Atom + 2,                            |         |
  % eqwalizer:fixme                        |         |
  erlang:list_to_binary(Atom),             |         |
  % eqwalizer:fixme                        |         |
  error.                                   |         |
                                           |         |
-spec fixmes_neg(atom()) -> ok.            |         |
fixmes_neg(Atom) ->                        | ERROR   |
  % eqwalizer:fixme                        |         |
  _ = Atom + 2,                            |         |
  error.                                   |         | 'error'.
                                           |         | Expression has type:   'error'
                                           |         | Context expected type: 'ok'
                                           |         |
-spec redundant_fixme() -> ok.             |         |
redundant_fixme() ->                       | OK      |
  % eqwalizer:fixme                        |         | redundant fixme

  ok.                                      |         |
                                           |         |
% Error tolerance with fun args            |         |
-spec make_pair(K, number()) -> {K, number……         |
make_pair(K, V) -> {K, V}.                 | OK      |
                                           |         |
-spec map_pair([{K, V}], fun ((K, V) -> {K……         |
map_pair(_, _) -> error(unimplemented).    | OK      |
                                           |         |
-spec apply_map([{atom(), term()}]) -> [{a……         |
apply_map(L) ->                            | ERROR   |
    map_pair(L, fun make_pair/2).          |         | Arg 2 of 'make_pair/2'.
                                           |         | Expression has type:   term()
                                           |         | Context expected type: number()
